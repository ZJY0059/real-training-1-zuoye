# day-01
## 1. git是什么,版本控制
他是一种在开发的过程中用于管理我们对文件,目录或工程等内容的修改历史,方便查看更改历史记录,备份以便以前的版本的软件工程技术
- 实现跨区域多人协同开发
- 追踪和记载一个或者多个文件的历史记录
- 组织和保护你的源代码和文档
- 统计工作量
- 并行开发、提高开发效率
- 跟踪记录整个软件的开发过程
- 减轻开发人员的负担，节省时间，同时降低人为错误
简单说就是用于管理多人协同开发项目的技术
## 2.  集中版本控制 SVN
所有的版本数据都保存在服务器上,协同开发者从服务器上同步更新或上传自己的修改,集中式版本控制



![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



缺点：所有的历史代码都存在服务器中,一旦服务器崩溃,代码就会丢失,且不能找回

优点：个人本地占用存储空间较小，只需要保存自己修改的内容即可



## 3. 分布式版本控制 Git

每个人都拥有全部的代码！安全隐患！

所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。

不会因为服务器损坏或者网络问题，造成不能工作的情况



![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



## 4. Git与SVN的主要区别

SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。



![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！

Git是目前世界上最先进的分布式版本控制系统。

## 5. 常用的Linux命令

```js
1）cd : 进入目录。
2）cd . . 回退到上一个目录，直接cd进入默认目录
3）pwd : 显示当前所在的目录路径。
4）ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。（Mac只有ll）
5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。
6）rm:  删除一个文件, rm index.js 就会把index.js文件删除。
7）mkdir:  新建一个目录,就是新建一个文件夹。
8）rm -r :  删除一个文件夹, rm -r src 删除src目录
9）mv 移动文件, mv index.html src。 index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。
10）reset 重新初始化终端/清屏。
11）clear 清屏。
12）history 查看命令历史。
13）help 帮助。（Mac除外）
14）exit 退出。
15）#表示注释
16) ls: 查看桌面的所有文件
17) Desktop 桌面
```

## 6.上传到gitHub

```js
1.打开git push
2.cd Desktop 进入桌面文件
3.mkdir 新建一个文件夹
4.cd 进入这个文件夹
5.git clone 网址里面自己得建得路径 克隆远程目录将远程服务器上的仓库完全镜像一份到本地
6.修改文件内容
7.git add . 添加所有文件到暂存区
8.git commit -m '修改'  提交暂存区中的内容到本地仓库
9.git push 网址名字 网址路径   把本地仓库里的内容传到远程服务器的仓库
10.git status 可以去查看所有文件的状态
```

# day-02

## 1. Js数组类型

1.基本数据类型

​	number(数字)  String(字符串)  undefined(未定义)  null(空)  boolean(布尔值)  symbol(符号)  bigint

​	symbol是es6新增的数据类型, 

​	特点是他的值是唯一 ,它可以被专门的Object.getOwnPropertySymbols()方法遍历出来。该方法返回一个数组

2.引用数据类型【对象类型】

​	(1) 标准普通对象: object(对象)

​	(2) 标准特殊对象： Array(数组)  RegExp(正则表达式)  Date(日期)  Math  Error(错误对象)...

​	(3) 非标准特殊对象：Number(数字)  String(字符串)  Boolean(布尔值)....

​	(4) 可调用对象/执行对象：function(函数)

​	简单来说: 数据类型分为基本数据类型(**放在栈里**)和复杂数据类型(**放在堆里**)

## 2. 数据类型转换

### 1.转换为Number类型

**①Number**
转换规则：
1.字符串转换为数字：空字符串变为0，如果出现任何非有效数字字符，结果都是NaN

```js
 let strnum = '123'
 let num=Number(strnum)
 console.log(num);    //123
 console.log(typeof num);   //number


console.log(Number(''));//0
console.log(Number('10'));//10
console.log(Number('10px'));//NaN

用Biglnt去除'n'
console.log(Number(1n));//1
```

**②parseInt **转换规则：转换成一个整数

```js
let parStr = '12.3'
let parse = parseInt(parStr)
console.log(parse);   //12
    // parseInt 取整 
```

**③parseFloat**转换规则: 转换成浮点型

```js
let parsetflots = '12.35aa'
let parflotStr = parseFloat(parsetflots)
console.log(parflotStr);


console.log(parseFloat(10.1)); //10.1
console.log(parseFloat('10.1')); //10.1
console.log(parseFloat(null)); //NaN
console.log(parseInt(10.1)); //10
```

### 2.转换为String类型

  **①String** 转换规则：除对象以外，都是直接用字符串包起来

```js
   var a1 = 10
   var b1 = String(a1)    //将数字10转换成字符串
   console.log(b1);     
   console.log(String(1));    //1
   console.log(String(NaN));   //NaN
   console.log(String(Symbol()));   //Symbol()
   console.log(String(null));    //null
   console.log(String(undefined));   //undefined
   console.log(String({}));    //[object Object]
   console.log(10 + new Date());  //10Wed Nov 16 2022 22:54:46 GMT+0800 (中国标准时间)
   console.log(10 + [10]);    //1010
```

  **②toString**

```js
 var Str1 = 10
 var Str2 = Str1.toString()
 console.log(Str2);
```



  **③+拼接**

```js
console.log(10 + '10');    //1010
console.log(10 + new Date());  //10Wed Nov 16 2022 22:54:46 GMT+0800 (中国标准时间)
```



## 2. 检测数据类型

### 1.typeof 返回对应类型得字符串

```js
let num = 123
let str = "123"
let bool = true
let arr = []
let obj = {}
let fn = function () { }
let cla = class { }
console.log(typeof num); // number
console.log(typeof str); // string
console.log(typeof bool); // boolean
console.log(typeof null); // object
console.log(typeof undefined); // undefined
console.log(typeof arr); // object
console.log(typeof Array); // function
console.log(typeof obj); // object
console.log(typeof Object); // function
console.log(typeof fn); // function
console.log(typeof cla); // function
console.log(typeof aaaaa) // undefined，未定义的变量也为undefined
```

**总结：typeof 检测基本数据类型比较准，null检测为object不代表它是引用数据类型，null为空是特殊的基本数据类型，引用数据类型都为 object，内置构造函数和函数都为 function**



### 2. instanceof 检测类型返回布尔值

```js
let num = 123
let str = "123"
let bool = true

let arr = []
let obj = {}
let fn = function () { }
let cla = class { }
let number = new Number(12)

console.log(number instanceof Number); // true
console.log(num instanceof Number); // false
console.log(str instanceof String); // false
console.log(bool instanceof Boolean); // false
console.log(null instanceof Object); // false
console.log(undefined instanceof Object); // false

console.log(arr instanceof Array); // true
console.log(arr instanceof Object); // true
console.log(obj instanceof Object); // true
console.log(fn instanceof Function); // true
console.log(fn instanceof Object); // true
console.log(cla instanceof Function); // true
console.log(cla instanceof Object); // true
```

**总结：instanceof 不能检测基本数据类型，判断前者的 proto 是否在后者的原型对象上  可以左边放你要判断的内容，右边放类型来进行JS类型判断**



### 3.constructor 返回构造函数

```js
let num = 123
let str = "123"
let bool = true

let arr = []
let obj = {}
let fn = function () { }
let cla = class { }
// 浏览器是这样打印的其实里面有很多内容，属性方法都有，可以使用 console.dir 打印
console.log(num.constructor);  // ƒ Number() { [native code] }
console.log(str.constructor);  // ƒ String() { [native code] }
console.log(bool.constructor); // ƒ Boolean() { [native code]

console.log(arr.constructor);  // ƒ Array() { [native code] }
console.log(obj.constructor);  // ƒ Object() { [native code] }
console.log(fn.constructor);  // ƒ Function() { [native code] }
console.log(cla.constructor);  // ƒ Function() { [native code] }
// 但是有一个小问题
function Demo() { }
Demo.prototype = Array.prototype
let demo = new Demo()
console.log(demo.constructor); // ƒ Array() { [native code] }
// 这个 demo 的 constructor 应该是对象的，但是我在它实例之前就把它的显示原型给更改为数组的，
// 它就会改变为数组的，也可以改变成其他的类型
```

**总结：返回当前值的构造函数，比如向 [] 数组这种，都是通过 new Array() 这样去创建实例的，这个 Array 就是数组的构造函数**



### 4.Object.prototype.toString.call()

```js
// Object.prototype.toString.call()，是把object的this指向括号中的并执行，
// apply也行，返回字符串[object 首字母大写的其他类型]
let num = 123
let str = "123"
let bool = true

let arr = []
let obj = {}
let fn = function () { }
let cla = class { }

console.log(Object.prototype.toString.call(num));// [object Number]
console.log(Object.prototype.toString.call(str));// [object String]
console.log(Object.prototype.toString.call(bool));// [object Boolean]
console.log(Object.prototype.toString.call(null));// [object Null]
console.log(Object.prototype.toString.call(undefined));//[object Undefined]

console.log(Object.prototype.toString.call(arr));// [object Array]
console.log(Object.prototype.toString.call(obj));// [object Object]
console.log(Object.prototype.toString.call(fn));// [object Function]
console.log(Object.prototype.toString.call(cla));// [object Function]
```

**总结：这个方法查的特别的准，可以检查任意类型**



### 5.Object.getPrototypeOf()

```js
// 获取原型，和想要的原型做对比
console.log(Object.getPrototypeOf([]) === Array.prototype); // true
console.log(Object.getPrototypeOf({}) === Object.prototype); // true
```

**五种方法得总结**



- ***typeof：这种方法只能检测基本数据类型，null 和对象的不准***
- ***instanceof：只要是基本数据类型检测就是false，只要是引用数据类型，并且右边是 Object 就是true，可以很好的区分是哪一大类型***
- ***constructor：可以检查基本和引用数据类型，但是可以被修改，有一定的缺陷***
- ***Object.prototype.toString.call()：这种方式是最准的，什么类型都可以检测***
- **Object.getPrototypeOf()：这种方法获取原型**



## 3.作用域及作用域链 变量

- **所谓作用域通俗讲就是变量得可作用范围**
- **一般有三种作用域为：全局, 函数, 块级(es6新增的)**
- **在作用域嵌套下，由内向外，一层一层往上的链式规则，这就是作用域链**、

全局就是js最外层的作用域，函数作用域是js通过函数创建的独立的作用域，函数可以嵌套，所有作用域也可以嵌套，在es6之前，只有函数才能创建局部作用域，创建了一个函数就创建了一个作用域，无论你调用不调用，只要你创建了，他就是个独立的作用域，作用域是自己没有这个变量就在上一级查找，直到找到顶部wds，

```js
var a = 100;
function fun1() {
  var b = 200;
  if (true) {
    let c = 300;
    console.log(c);
  }
  console.log(b);
}
fun1();
console.log(a);
```

### 1.变量提升及函数提升

##### 1.什么是变量提升？

变量提升是指将变量声明提升到它所在的作用域的最开始部分 但赋值操作不会提升

```js
console.log(str)
// undefined 
var str = 'Jerry'
console.log(str)
//Jerry

相当于
var str
console.log(str)
str = 'Jerry'
console.log(str)
```

##### 1.什么是函数提升

创建函数有两种形式，一种是函数声明，另外一种是函数字面量，**只有函数声明才有变量提升**

```js
console.log(a)  // f a() { console.log(a) }
console.log(b) //undefined

//函数声明
function a() {
		console.log(a) 
}

//函数表达式 
var b = function(){
		console.log(b)
}

//相当于
var a = 'function'
var b
console.log(a)
console.log(b)
```

**由此可见函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。**



## 4.运算符

### 1. 数学运算符

数学运算符就是常见的**加(+)、减(-)、乘(*)、除(/)、等于(=)、求幂(**)、**自增(++)、自减(--)、加等于(+=)、减等于(-=)**等

```js
let num = 0;
num = 1 + 3 - 4 / 2 * 2; // 0
num = num++; // 1
num = num--; // 0
num += 1; // 1
num -= 1; // 0
```

### 2. 比较运算符

与数学运算中的比较相同**：大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、相等(==)、全等(===)、不等(!=)、不全等(!==)**等；注意: **全等不光比较两者值是否相同，还比较变量类型是否相同；不全等也是一样**；

```js
1 == '1' // true 两者虽然类型不同但是==比较时会发生隐式类型转换进行比较
1 === '1' // false 前者是number类型，后者是string类型
```

### 3. 三元表达式

三元表达式可以替代简单的if条件，**表达式为判断条件 ？条件为真 ：条件为假**。例如：

```js
 if (3 < 4) {
        console.log('条件为真');
    } else {
        console.log('条件为假');
    }
    // 等同于:
// 三元表达式 —— 代码更加简洁清晰
    console.log(3 < 4 ? '条件为真' : '条件为假');
```

### 4.短路运算符 && 与 ||

**短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了**

- &&：从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值；

- || ：为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值；

## 5. 字符串的方法 String

### 1.length  代表字符串长度

```js
 var str = '一二三四五六七'
 console.log(str.length);   //7
 // 拿到这个字符串的长度
```

### 2. charAt() 返回指定位置的字符

字符串中，字符的位置也是***从0开始，依次递增***。

```js
 var str = '一二三四五六七'
    var a = str.charAt(5)
    console.log(a);    //六
    //    从0开始第5个是六
```

### 3. concat() 用于拼接两个或多个字符串

***不会修改原字符串，会将拼接好的字符串以返回值的方式返回出来***。

```js
 var str1 = 'abc'
    var str2 = 'def'
    console.log(str2.concat(str1));
    //   字符串的拼接也相当于合并字符串
```

### 4. indexOf() 查找 从前往后

- 可以在字符串中查找指定的字符。
- 可以查到的的话返回值字符所在的位置。
- 查不到返回 -1。
- 如果要查找的字符在字符中存在多个，永远只找一个。

```js
var str = '一二三四五六七'
    console.log(str.indexOf('二'));   //1
    // 二的下标为1
```

### 5. lastindexOf() 查找 从后往前

使用方法和 indexOf 一样。
 但是 indexOf 是从前往后查找，lastindexOf() 是从后往前查找

```js
var stringVal = "hrello world"
console.log(stringVal.indexOf("r"));    //1
console.log(stringVal.lastIndexOf("r"));   //9
```

### 6. replace() 替换

有两个参数

第一个参数，旧的字符

第二个参数，新的字符

不会修改原数组

会将替换好的数组以返回值的形式返回出来。
 如果旧的字符在字符串中不止一个，则替换第一个。

```js
 var str = '一二三四五六七'
 console.log(str.replace('二', '十'));   //吧二替换成十
 console.log(str);    //不会改到原数组里面
```

### 7.split() 将字符串转化成字符串数组

不会改变原数组  会将转化好的数组以返回值的形式返回出来 

如果括号中什么都不写  则将整个字符串作为数组的一个元素转化成数组,

如果括号中是空字符串，则将每个字符都作为一个数组的元素转化成数组

如果括号中写字符，则将这个字符变成逗号(,),并以其隔开数组元素

如果字符串中没有这个字符，效果相当于什么都不写,如果目标字符在开头或者结尾，则转成数组后，生成一个空字符串的元素

split 还有第二个参数：
 第二个参数代表转成数组后，所保留的元素的数量。（从以转化好的数组下标为0的元素开始）

```js
var str = '1一1二1三1四1五1六';
console.log(str);//   '1一1二1三1四1五1六'
console.log(str.split());//   ['1一1二1三1四1五1六']
console.log(str.split(''));//['1','一','1','二','1','三','1','四','1','五','1','六']
console.log(str.split('1'));//   ['','一','二','三','四','五','六']
console.log(str.split('1', 2)); //   [' ','一']
```

### 8.substr() 字符串的截取

有两个参数

 第一个参数：起始的位置

 第二个参数：截取的数量

不会改变原数组
 会将截取到的字符串以返回值的形式返回出来

```js
var str = '1一1二1三1四1五1六';
console.log(str.substr(1,3));//   '一1二'
```

### 9. substr()   字符串的指定位置的截取

有两个参数

 第一个参数：起始的位置（返回时包括位置所对应的字符）

 第二个参数：结束的位置（返回时不包括位置所对应的字符）

不会改变原数组
 会将截取到的字符串以返回值的形式返回出来

```js
var str = '1一1二1三1四1五1六';
console.log(str.substring(1,3));//   '一1'
```

### 10. toLowerCase()  大写字母转小写字母

不会改变原数组
 会将转换好的字符串以返回值的形式返回出来

```js
var str = 'AaBbCcDdEe';
console.log(str.toLowerCase());// aabbccddee
```

### 11.toUpperCase() 小写字母转大写字母

不会改变原数组
 会将转换好的字符串以返回值的形式返回出来

```js
var str = 'AaBbCcDdEe';
console.log(str.toUpperCase());//   AABBCCDDEE
```

### 12.search() 判断字符串包含

获取某个字符或者字符串片段首次出现的位置

```js
var str1="aaaaaaaaaaaaaaaabbbb";
var str2="aaaaaabb";
console.log(str1.search(str2)); //10
console.log(str2.search(str1)); //-1
```

## 6. vue组件传值

1.⽗传⼦

在⼦组件的标签上定义属性 ⼦组件通过props来进⾏接收,可以通过数组或者对象的⽅式接收,如果⽗组件没有传递属性,⼦组件可以default来设置默认值

父传子的使用场景 封装列表的时候 把数据传到子组件渲染

2.⼦传⽗ 

⼦组件通过this.$emit("⾃定义的事件的名字",要传给⽗组件的数据), ⽗组件通过⼦组件的标签监听⾃定义的时间,最后在父组件接收使用就可以了

子传父的使用场景：在子组件中有删除等方法的时候要在子组件把下标传到父组件操作数据

3.兄弟组件

通信
通过中央事件总线,我们也称之为eventBus,

在main.js定义一个空的vue实例并且挂载在原型上,通过$emit传数据,在要接收的子组件的created钩子函数下通过$on接收

4.vuex把公共数据存在vuex里这样就能实现组件通信

5.本地存储
把要传递的数据存在本地存储里,再要接收的组件接收,也能实现组件通信

6.v-model
v-model是一个语法糖 是:value和@input的合写 所以说能实现组件通信

7.$attr和$listener

主要是祖孙之间传值 父组件下面有子组件a 子组件a下面又有 子组件b 在父组件里还是用自定义属性和自定义事件传 在子组件a下面绑定v-bind="$attrs" v-on="$listeners" 在子组件b下面通过$attrs 拿数据 通过 $emit 调用方法

8.provide 和 inject
不管嵌套了几层都能拿到数据 把数据定义在 provide 里 在子组件通过 inject 拿到数据 缺点是不响应
9.children 和 parent
在子组件里通过$parent 拿到父组件的数据和方法
在父组件里通过$children 拿到子组件的数据和方法



# day-03

## 1.数组的方法

### 常见数组方法如下

**判断是否是数组:**

- isArray()

**添加修改数组：**

- push()
- pop()
- shift()
- unshift()
- slice()
- splice()
- sort()
- reverse()

**是否包含某元素：**

- indexOf()
- includes()

**转换：**

- toString()
- join()

**数组循环：**

- map()
- forEach()
- filter()
- find()
- findIndex()
- erery()
- some()
- reducw()
- reduceRight()

### 1.isArray()(判断是否是数组)

判断是不是一个数组 返回的是一个布尔值

```js
let arr = [1,2];
console.log(arr.isArray()); //true

let Strarr = '1,2,3'
console.log(Array.isArray(Strarr))   //false

//如果他是一个数组就返回true 不是就返回false
```

### 2. push(尾部添加)

可以添加一个或多个参数到数组的**尾部**，添加之后原来的数组会发生改变，返回的是添加后的数组的长度

```js
  let arr = [1, 2]
  let arr1 = arr.push(3, 4, 5)
  console.log(arr);    //添加后的数组，原数组会发生改变
  console.log(arr1);   //5
```

### 3. pop()(尾部删除)

从数组尾部删除一个元素，原数组会发生改变，返回数组中被删除的元素

若该数组为空，则返回undefined

```js
   let arr = [1, 2, 3]
   let del = arr.pop()
   console.log(arr);    //[1.2]
   console.log(del);     //3
```

### 4. unshift()(头部添加)

可以添加一个或多个参数到数组的**头部**，添加后原来的数组会发生改变，返回的是添加后的数组的长度

```js
  let arr=[1,2,3]
  let arr1=arr.unshift(4,5)
  console.log(arr);    //原数组发生改变   //[4, 5, 1, 2, 3]
  console.log(arr1);    //5
```

### 5. shift()(头部删除)

从数组头部删除一个元素，原数组会发生改变，返回数组中被删除的元素

若该数组为空，则返回undefined

```js
let arr = [1, 2, 3]
let del = arr.shift()
console.log(del);    //1
console.log(arr);   //[2,3]
```

### 6. concat() (合并)

合并两个或多个数组，生成一个新的数组。原数组不变

```js
let arr = [1, 2]
let b = [3, 4]
console.log(arr.concat(b));
```

### 7. sort()(排序)

对数组元素进行排序，是排序后的数组 原数组也会发生改变

```js
 let arr = [1, 2, 4, 3];
    // 升序
 arr.sort((a, b) => {
        return a - b;
    });
 console.log(arr);   //[1, 2, 3, 4]
    // 降序
 arr.sort((a, b) => {
        return b - a;
    })
 console.log(arr);   //[4, 3, 2, 1]
```

**原理**

1. **当返回值为负数时，那么前面的数在前面，也就是不动**
2. **当返回值为正数时，那么后面的数在前**
3. **为0，不动**

### 8. reverse()(翻转)

将数组倒序。原数组改变

```js
 let arr = [1, 2, 3, 4]
 console.log(arr.reverse());     //[4, 3, 2, 1]
```

### 9. join()(分割)

***将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号。***

```js
 let arr = [1, 2, 3, 4];
 let str = arr.join();
 let str1 = arr.join('-');
 console.log(str); // 1,2,3,4
 console.log(str1); // 1-2-3-4
```

### 10. toString()(转换为字符串)

此方法将数组转化为字符串

```js
 let arr = [1, 2, 3, 4, 5];
 let str = arr.toString()
 console.log(str)// 1,2,3,4,5
```

### 11. slice()(截取数组)

截取数组 原数组不变 返回新的数组 

参数是开始的位置 结束的位置 包头不包尾 参数是负数 就加上数组的长度 一个参数 就直接截到最后

```js
 let a = ['项目一', '项目二', '项目三']
 let arr = a.slice(0, 2);
 console.log(a); // ["项目一","项目二","项目三"]
 console.log(arr); // ["项目一","项目二"]
```

### 12. splice()

删除 替换 增加 原数组发生改变;

删除 传两个参数 开始的位置 删除的个数 返回值删除的值;

替换和插入 是三个甚至更多参数;开始的位置 删除的长度（要插入的话第二个参数是 0） 要替换或者插入的值

```js
let arr = [1, 2, 3];
let result = arr.slice(1, 0, 33);
console.log(arr); // [1,2,33,3]
console.log(result); // []
```

### 13. indexOf()(查找)

  来查找某个元素的位置,找到返回下标,如果不存在就返回-1 

  但是不能判断是否有NaN的元素

```js
let arr = ['项目一','项目二','项目三'];
let result = arr.indexOf('项目二');
console.log(arr); // 1
```

### 14. includes()(含有)

判断是否包含某一元素,直接返回true或者false表示是否包含元素，

 对NaN一样有效

```js
 let arr = ['项目一', '项目二', '项目三'];
 let result = arr.includes('项目二');
 console.log(result) // true   有这个数值的话，就是true没有就是false
```

### 循环方法

### 1.map

- 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
- 不改变原数组
- 返回值是一个新的数组

```js
 let testArr = ['子项0', '子项1', '子项2'];
 let resultArr = testArr.map((item, index) => {
        return `处理·${item}`
    });
 console.log(testArr);   //原数组不会发生改变
 console.log(resultArr);
 //结果： ["处理·子项0", "处理·子项1", "处理·子项2"]
```

### 2. forEach

- 对数组的每个元素执行一次提供的函数。
- ***总是返回undefined。***
- 对原数组发生改变
- 没有return

```js
 let testArr = ['子项0', '子项1', '子项2'];
 testArr.forEach((item, index) => {
      console.log(item);
    });
```

### 3.filter(过滤)

- 对数组的每一项都进行***过滤***，返回符合条件的item组成的数组
- ***不会改变原数组***
- 返回值就是新数组

```js
    let arr = [1, 2, 3]
    let arr1 = arr.filter((item, index) => {
        return item == '1'
    })
    console.log(arr);   //[1,2,3]
    console.log(arr1);  //[1]
```

### 4. find(查找)

- 遍历数组，找到第一个符合条件的项，并返回该项。否则返回undefined
- 不会改变数组

```js
 let arr = [1, 2, 3]
 let arr1 = arr.find((item, index) => {
    return item == '1'
   })
 console.log(arr);
 console.log(arr1);  //1
```

### 5. findIndex

- ***遍历数组找到第一个符合条件的项，并返回该项的索引值。否则返回-1。***
- 不会改变数组对象

```js
    let arr = [1, 2, 3]
    let arr1 = arr.findIndex((item, index) => {
        return item == '1'
    })
    console.log(arr);
    console.log(arr1);   //返回的下标
```

### 6.every

对数组中的每一项运行给定函数，如果该函数对每一项返回true, 则返回true，

简单说就是看数组的每个元素是否符合要求，都符合则返回true，否则返回false

```js
 let everyArr = [2, 3, 4];
 let everyResult = everyArr.every((item, index) => {
        return item > 0
    });
 console.log(everyResult);
    // 结果为: true
```

### 7. some

是对数组中每一项运行指定函数，如果该函数对 任一项返回true，则返回true

遍历数组中数组中至少有一个满足条件的数组项,返回true否则false

```js
   let someArr = [2, 3, 4];
   let someResult = someArr.some((item, index) => {
            return item > 3
        });
   console.log(someResult);
    // 结果为: true
```

### 8. reduce

- 接收一个函数作为累加器（accumulator），数组中的每个值***（从左到右）***开始缩减，最终为一个值。
- 第二个参数作为第一次调用的a的值

```js
let reduceArr = [0,1,2,3,4]
let reduceResult = reduceArr.reduce((a, b)=>{
  return a + b;
});
console.log(reduceResult);
// 结果: 10
```

## 2. 闭包

闭包的理解就是函数中套了一个函数，内层函数可以访问到外层函数的变量，闭包可以封装对象的私有属性和方法，闭包作为回调函数，可以实现函数的复用，

有返回值,返回值是一个回调函数

```js
 function person() {
        let name = 'Peter';
        return function person1() {
            console.log(name);
        }
    }
    let peter = person()
    peter()
```

优点：可以重复使用变量不会造成变量的污染，延长变量生命周期

缺点：闭包会使变量都存在内存中，内存消耗很大，所有不能滥用闭包，会造成网页的性能问题，会导致内存泄露

## 3. 事件循环 eventloop

js是一个单线程的 同一时间只能执行一个任务,但是这并不意味着单线程就是阻塞,而实现单线程非阻塞的方法就是事件循环

在js中,任务分为同步任务和异步任务

同步任务：在主线上执行,形成一个执行栈,前一个任务执行完才能执行后面的

异步任务：通过回调函数实现在任务同事也可以做其他任务

异步任务又分为宏任务和微任务

宏任务：setTimeout  settinterval ajax dom事件监听

微任务：.then async awalt

优先执行同步任务

遇到异步任务推入任务队列中,等同步任务执行完再执行队列里的异步任务

异步任务又分宏任务和微任务,先执行微任务,再执行宏任务

```js
   console.log(1);
    // 同步任务
    setTimeout(() => {
        console.log(2);
        // 异步任务的宏任务
    }, 0)
    new Promise((resolve, reject) => {
        console.log(3);
        // 异步任务的微任务
        resolve()
    }).then(() => {
        // 同步
        console.log(4);
    })
    // 同步任务
    console.log(5);
```

## 4.this的指向

在 js 中 this 不是固定不变的，它会随着执行环境的改变而改变。要注意的是 this 取什么值，是在执行时确认的，定义时无法确认。

this 的调用大概分为五种场景： 

1.浏览器里，在全局范围内的 this 指向 window 对象； 

2.在函数中，this 永远指向最后调用他的那个对象；

3.构造函数中，this 指向实例对象； 

4.箭头函数 没有this 是根据上下文的this来决定的 箭头函数 this 为父作用域的 this，

有三个方法改变 this：

call:参数是单个使用的，

apply:参数是一个数组

call 和 apply 都会立刻调用这个函数

bind:只改变 this 不会让函数立刻调用

###  1.this的绑定规则

this的绑定和定义的位置（编写的位置）没有关系；

this的绑定和调用方式以及调用的位置有关系；

### 1.绑定方法

#### 绑定一：默认绑定

独立的函数调用，我们可以理解成函数没有被绑定到某个对象上进行调用；（this指向window）



#### 绑定二：隐式绑定

也就是它的调用位置中，

是通过某个对象发起的函数调用(谁调用this指向谁)



#### 绑定三：显示绑定

- 必须在调用的对象内部有一个对函数的引用（比如一个属性）；
- 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；
- 正是通过这个引用，间接的将this绑定到了这个对象上

#### 绑定四：new关键字

  指向实例话对象（除非构造函数返回一个引用类型，则new失效。this指针绑定变为返回的引用类型）

```js
  创建一个空对象；

　　将空对象的原型，指向于构造函数的原型；

　　将空对象作为构造函数的上下文（改变this指向）；

　　对有返回值的构造函数做判断处理
```



#### 绑定五：箭头函数的绑定

 箭头函数就比较特殊了，他没有明确的指向，他里面的 this 其实是根据他的上级来定的，也就是他的 this 指向等于他的上级



## 5. 深拷贝 浅拷贝

深拷贝：

拷贝的值 开辟独立空间互不影响

创建一个新的对象和数组，将原对象的各项属性的值拷贝过来，新对象和原对象不共享内存，修改新对象不会改到原对象

1.JSON.parcse(JSON.Stringify())

```js
JSON.parse(JSON.stringify())
let string = '[1,2,3]';
console.log(JSON.parse(JSON.stringify(string)))//[1,2,3]
// JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象
```

2.递归实现

```js
  function deepcopy(obj) {
        let res = {};
        //保存复制之后的数据
        for (const key in obj) {
            if (obj[key] instanceof Object) {
                res[key] = deepcopy(obj[key]);
                //自身调用自身 如果是复杂数据类型就重新进行递归调用
            } else {
                res[key] = obj[key];
                //如果是基本数据类型就进行复制
            }
        }
        return res;
    }
```

浅拷贝

拷贝的是地址 两者公用一个内容

浅拷贝：将原对象引用直接赋给新对象，新对象只是原对象的一个引用，而不复制对象本身，新旧对象还是同用一个内存



1.展开运算符

```js
let arr2 = [...arr];
```



2.concat()合并

```js
let arr2 = arr.concat();
```

3.、Object.assign()

```js
let arr2 = Object.assign({}, arr);
```



## 6.原型及原型链

### 1. 什么是原型？

**注意: 构造函数的首字母一定是大写的**

原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。

```js
function Person () {
    //...
}

```

我们不在这个构造函数里写任何代码，当我们在浏览器控制台通过`console.dir`打印出这个构造函数时，可以看到它被添加了一个属性`prototype`。



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0be9dc80817b4cf79818c0718a5775b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)



**构造函数`Person`通过`prototype`属性就能访问到它的原型对象，`Person.prototype`就是原型对象** 

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3028f79561d7479fad2e5046b93c75c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

通过`Person`构造函数创建一个实例时

```js
function Person () {
    //...
}
const person = new Person() // 通过new操作符创建一个实例
console.log(person instanceof Person) // true
```

那么`person`实例可以访问`Person`构造函数的原型对象吗? 显然是可以的。

通过new创建的实例上有一个`__proto__`属性（注意⚠前后是两个下划线）可以直接访问原型对象`Person.prototype`。通常，我们将`__proto__`属性称为**隐式原型属性**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cce3b382a18b49748a9ff9e103276b07~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)



在原型上定义的属性和方法，在实例上能够继承这些属性和方法

```js
function Person () {
    //...
}
Person.prototype.sayHi = 'Hi'
const person = new Person() // 通过new操作符创建一个实例
console.log(person.sayHi)   // Hi
console.log(person.__proto__ === Person.prototype) // true
```

如果原型对象`Person.prototype`需要访问它原来的构造函数可以通过`constructor`属性，



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf50095d54cd47a6a681a27df9ee501e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

```js
function Person () {
    //...
}
Person.prototype.sayHi = 'Hi'
const person = new Person() // 通过new操作符创建一个实例
console.log(person.sayHi)   // Hi
console.log(person.__proto__ === Person.prototype)   // true
console.log(Person.prototype.constructor === Person) // true
```



### 2.什么是原型链？

当我们需要读取实例上的属性时，JS会先在当前实例上查找是否有该属性，如果没有则通过`__proto__`访问原型去查找是否有该属性，如果有的话就可以直接使用，没有的话，就会再通过`__proto__`去访问原型的原型，因为原型也是一个对象



`Person.prototype`可以看做是`Object`的实例，这样的话`Person.prototype`通过`__proto__`访问的是`Object`的原型`Object.prototype`，`Object.prototype`也有一个`__proto__`属性，只不过这次不套娃了，它指向的是`null`



**当我们访问一个实例的属性或方法时，会先在当前实例上查找，若查找不到，会到原型上查找，若原型上查找不到，就到原型的原型上查找，若还是查找不到就指向null**

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67aed29f79db452c9516589a575ff0ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)



上面提到的：`Person.prototype`可以看做是`Object`的实例。

其实我们在JS中创建的对象都是`Object`的实例，他们都会继承`Object`原型对象上的属性和方法，并且 `创建的对象.__proto__ === Object.prototype`

```js
const obj = {}
console.log(obj.__proto__ === Object.prototype) // true
console.log(obj.toString)  // ƒ toString() { [native code] }，toString是继承Object.prototype上的方法

const obj2 = new Object()
console.log(obj2.__proto__ === Object.prototype) // true
console.log(obj2.toString) // ƒ toString() { [native code] }
```

既然`Person.prototype`可以看做是Object的实例。那么就可以在Object处引出一个箭头指向`Person.prototype`，表示通过new创建一个实例对象。最后，再把节点和连线调整一下



![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba8bb2b3b134c5681eea31bc3c1a8db~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

### 3.如果方法放在原型上继承的缺点

- 构造函数创建对象的时候,当构造函数方法很多时,其结构很复杂
- 每次实例一个对象，都需要开辟一个空间 造成内存严重浪费
- 每一个对象的属性和方法都是独立的,不会互相影响,无法做到数据的共享

### 4. 原型的缺点和优点

优点：

- 可以让构造函数结构变的简单
- 可以节省内存的空间
- 每一个实例可以共享原型上的方法和属性,达到数据共享

缺点：

- 因为数据存在共享,所有可以被修改或者覆盖

### **5. 总结**

1. 什么是原型？

**原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。**

2. 什么是prototype?

   **显示原型，是函数（不包含箭头函数）本身存在的一个属性，他指向的是一个对象，即为原型对象。**

3. 什么是 __ proto __ ?

**可以称为隐式原型，或者叫连接点。是对象的一个属性，它里面存储的是该构造函数的原型对象，即prototype.**

4. 什么是构造函数？

**构造函数其实是一种特殊的函数，主要用来初始化对象，也就是为对象成员变量赋初始值，它总与new关键字一起使用**

5. 什么是原型链？

**当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**



## 7.继承的方法

### 1.原型继承

```js
 function Super(){
            this.a=1
    }
        // 定义构造函数Super
   Super.prototype.say=function(){
            console.log('hhh');   //hhh
        }
        // 给Super原型上say赋值
  function Sub(){}
        // 定义构造函数Sub
  Sub.prototype=new Super()
        // 实例化构造函数Super赋值到Sub的原型上
   const test =new Sub()
        // 实例化构造函数Sub赋值到test变量上
   console.log(test.say());   //undefined
// sub继承super的原型,test继承sub实例,所有sub继承了super实例
```

优点：通过原型继承多个引用类型的属性和方法

缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题

### 2.盗用构造函数继承

通过   构造函数模式+call

```js
    let Super=function(){
            this.a=1;
        }
        // 把一个匿名函数赋值给Super
        Super.prototype.c=3;
        // 改变this指向sub和test只能获取到Super的属性,像Super原型上的是获取不到的
        let Sub=function(){
            Super.call(this);
            // call方法改变了this之前Super指向Window现在指向了Sub,同时Sub就拥有了Super的属性,但是获取不到Super的原型
            this.b=2;
        }
        // 把一个匿名函数赋值给Sub
        Sub.prototype.d=4;
        // test能获取到Sub的原型
        const test=new Sub();
        // 把实例化的sub赋值给test
        console.log(test);//Sub{a=1,b=2}
```

优点：每一个构造函数都有自己的属性和方法不会造成污染

缺点：构造函数上的方法在每一个实例上都要创建一遍

### 3. 组合继承

通过 原型继承+盗用构造函数继承

```js
  function Super() { this.a = [1, 2] }
        // 定义构造函数Super
 Super.prototype.say = function () { console.log('hhh') }
       // 给Super构造函数原型上赋值
  function Sub() {
            Super.call(this)
            // 把Super构造函数的this指向从Window改成了Sub,Sub能获取Super的属性(盗用构造函数继承)
            this.b = 2
        }
        // 定义构造函数Sub
        Sub.prototype = new Super()
        // 实例化Super赋值给Sub的原型,Sub可以获取Super构造函数的原型方法
        const test1 = new Sub()
        // 把实例化Sub赋值给test1
        console.log(test1.say());//hhh
        // test1可以获取到Super的原型方法
        test1.a.push(3)
        console.log(test1.a);//[1,2,3]
        const test2 = new Sub()
        // 把实例化Sub赋值给test2
        console.log(test2.a);//[1,2]
        // super每次都会被调用两次所以改变test2变量不会影响Super不会造成污染
```

优点：集合了【原型继承】和【盗用构造函数继承】的优点

缺点：存在效率问题，Super始终会被调用两次

### 4. 原型式继承

es5之前

```js
const obj={a:1};
    // 定义一个obj对象
 function createObj(o){
    function Fn(){}
            // 定义构造函数Fn
    Fn.prototype=o
            // 接收obj对象赋值到Fn构造函数的实例中
    return new Fn()
            // 把实例化构造函数Fn()返回出去
        }
        // 定义一个函数createObj
 const test =createObj(obj)
        // 相当于把Fn实例化赋值给test
  console.log(test);
```



es6之后

```js
const obj = { a:1 }

const test = Object.create(obj)
```

优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性

缺点：无法判断实例的构造函数是父类还是子类

### 5. 寄生式继承

通过 构造函数模式+工厂模式

```js
function createObj(o){
    let clone = objectCopy(o)
    clone.say=function(){
        console.log(‘hhh’)
    }
    return clone
}

const obj = { a:1 }
const test = createObj(obj)
```

优点：根据一个对象克隆创建另一个对象，并增强对象

缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

### 6. 寄生式组合继承

通过 盗用构造函数继承 + 原型式继承

```js
function Super(){ this.a=[1,2] }
Super.prototype.say = function(){ console.log(‘hhh’) }
function Sub(){
    Super.call(this)
    this b=2
}

Sub.prototype = Object.create(Super.prototype)
Sub.prototype.constructor = Sub

const test = new Sub()
```

优点：继承完整

缺点：同盗用构造函数方法在每一个实例上都要创建一遍

# day-04

## 1.获取dom节点的方法

### 1.通过id获取

- 语法：`document.getElementById('ad')`
- 必须传参数，参数是string类型，是获取元素的id。
- 返回值只获取到一个元素，没有找到返回null。

### 2. 通过标签名获取

- 语法：`document.getElementsByTagName('div')`
- 上下文可以是document，也可以是一个元素，注意这个元素一定要存。
- 参数是是获取元素的标签名属性，不区分大小写
- 返回值是一个类数组，没有找到返回空数组

### 3. 通过name属性获取

- 语法：`document.getElementsByName('123')`

- 必须传参数，参数是是获取元素的name属性
- 返回值是一个类数组，没有找到返回空数组

### 4. 通过类名获取

- 语法：`document.getElemensByClassName('animated')`
- 参数是元素的类名。
- 返回值是一个类数组，没有找到返回空数组。

### 5. 通过选择器获取一个元素

- 语法：`document.querySelector('.ad')`
- 上下文可以是document，也可以是一个元素
- 参数是选择器，如：”div .className”。
- 返回值只获取到第一个元素。

### 6. 通过选择器获取一组元素

- 语法：`document.querySelectorAll('.ad')`
- 上下文可以是document，也可以是一个元素
- 参数是选择器，如：”div .className”
- 返回值是一个类数组。

### 7. 通过body获取

语法：`document.body`

document.body是专门获取body这个标签的

## 2. 伪数组和数组的区别

### 伪数组

1. 伪数组是一个对象(Object)，而真实的数组是一个数组(Array)
2. 拥有length属性，且`必须是number类型`,其它属性（索引）为`字符串`
3. `不具有数组所具有的方法`,forEach()等,不过有Object的方法
4. 伪数组`长度不可变`,真数组长度可以变
5. 可以通过`for in遍历`

```js
 // fakeArray就是一个伪数组
    var fakeArray = {
        length: 3,
        "0": "first",
        "1": "second",
        "2": "third"
    }
   console.log(fakeArray);   //伪数组原型指向的是object
    var arr = [1, 2, 3, 4]

    // 真数组的方法来自Array.prototype
    console.log(fakeArray instanceof Array) //false
    console.log(arr instanceof Array) // true

    Array.isArray(fakeArray) // false;
    Array.isArray(arr) // true;

    console.log(arr.__proto__ === Array.prototype) // true
    console.log(fakeArray.__proto__ === Array.prototype) // false
    console.log(fakeArray.__proto__ === Object.prototype) // true

    arr.forEach(x => console.log(x)) // 1 2 3 4
    fakeArray.forEach(x => console.log(x)) // fakeArray.forEach is not a function

    Object.keys(fakeArray) //  ["0", "1", "2", "length"]
```

### 常用的伪数组



1. 参数数组：arguments
2. DOM对象列表HTMLCollection()：比如通document.getElementsByTagName得到的列表
3. jquery对象：比如$(“div”)

### 伪数组转换为真数组

**1.使用Array.prototype.slice.call()**

```js
var fakeArray = {
    length: 3,
    "0": "first",
    "1": "second",
    "2": "third"
}
// 将伪数组转换为真数组
var arr = Array.prototype.slice.call(fakeArray) 

console.log(arr) // ["first", "second", "third"]
Array.isArray(arr) // true
console.log(arr instanceof Array) // true
arr.forEach(x => console.log(x)) // first second third

```

**2.使用es6中的Array.from方法**

```js
var fakeArray = {
	length: 3,
    "0": "first",
    "1": "second",
    "2": "third"
	}
var arr = Array.from(fakeArray)
console.log(arr) // ["first", "second", "third"]

```

## 3. argoments整理

 这里我们可以看到arguments对象将我传入的五个参数以数组的形式保存在里面，还有保存了我传入函数的实参的个数（length）。

 而且我们可以看到arguments对象的 __ proto __ 是指向object的，这也说明了他是个类数组对象，而不是一个数组。

 有了这个对象我们以后写函数的时候，就不用给所有的形参指定参数名，然后通过参数名的方式获取参数了，

 我们可以直接使用arguments对象来获取实参，这样是不是方便了很多呢。

 有些语言在我们给函数指定了参数名之后，当调用函数时，会判断当前传入的参数是否与函数定义的参数个数相等，不相等就会报错

```js
   function showargs() {
        console.log(arguments);
    }

    showargs(1, 2, 3, 4, 5);
```

可以看到arguments还有一个叫做callee的属性，这个属性是表示的是当前函数的一个引用

  简单点说，这个属性里面存储的我们调用的这个函数的完整代码

```js
   function showcallee() {
        var a = '这里是代码';
        var b = '这是另一段代码';
        var c = a + b;

        console.log(arguments.callee);

        return c;
    }
    showcallee();
```

利用arguments对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回

```js
 function add() {
        var len = arguments.length,
            sum = 0;
        for (; len--;) {
            sum += arguments[len];
        }
        return sum;
    }

    console.log(add(1, 2, 3));   //6
    console.log(add(1, 3));     //4
    console.log(add(1, 2, 3, 5, 6, 2, 7));   //26
```

## 4.es6的变量结构赋值

从数组和对象中提取值,对变量进行赋值,这被称为解构

变量的解构赋值可以是任意类型比如常用的String类型、数值类型和布尔类型，这些都可以。数组、Object也可以的。

```js
var [c,d,e] = [3,4];
```

没有给变量e赋值不会报错，只是一个undefined，

变量只有两个，而值有三个。也不会报错，就只会赋两个的值。


```js
 //允许默认值
var [c,d,e = "默认值"] = [3,4];

```

## 5. 模板字符串

```js
   // 原生的模板拼接
    let res = '<ul>'
        + '<li>沈腾</li>'
        + '<li>沈腾</li>'
        + '</ul>';
    

    let res1 = `
        <ul>
            <li>666</li>
            <li>666123</li>
            <li>666555</li>
            </ul>
         `


    document.write(res)
    document.write(res1)
```

## 6.箭头函数

```js
  function getname() {
        console.log(this.name);   //股   //123
    }
    let getname1 = () => {
        console.log(this.name);    //股   //股
    }
    window.name = '股'
    const School = {
        name: '123'
    }
    getname()   
    getname1()
    getname.call(School)
    getname1.call(School)  
//箭头函数没有this,他的this是School的,指向还是window


```

## 7. es6 对象的简写写法

```js
  let name = '高新';
    let hope = function () {
        console.log("能够高新");
    }
    //   原本的
    // const Perst = {
    //     name:name
    //     hope=function(){

    //     }
    // }


    // es6可以简写
    const Perst = {
        name,
        hope,
    }
    console.log(Perst);
```

## 8. es6 rest

es6引用rest参数,用于获取函数的实参,用来代替arguments

 es5获取实参的方法

```js
function date() {
      console.log(arguments);
    }
   date('1', '2', '3')
```

rest参数

```js
 function date(...args) {
        console.log(args);
    }
    date('1', '2', '3')
```

rest 参数必须要放在参数最后

```js
  function fn(a, b, ...args) {
        console.log(a);
        console.log(b);
        console.log(args);
    }
    fn(1, 2, 3, 4, 5, 6)
```

## 9. 扩展运算符

```js
   // ...  扩展运算符能将数组转换为逗号分隔的 
    const arr=['1','2','3']
    // 声明一个数组
    function change(){
        console.log(arguments);
    }
    change(...arr) 



const Arr=['1','2','3']
const Arr1=['4','5','6']
console.log(...Arr,...Arr1);   //1 2 3 4 5 6
```

## 10. let const 

### 1.let 特点：

- 变量不能重复声明(当前作用域不能进行重复声明,下一个作用域可以重复声明)

- 块级作用域

- 不存在变量提升
- 不影响作用域链

```js
  //变量不能重复声明
   let star='123'
   let star='222'
   //会报错
```

### 2. const 特点：

cosnt 一般都是开头大写

const 是声明常量的 常量不能修改

声明基本数据类型不能修改  声明复杂数据类型可以修改

# day-05

### 1.Pomise

prominse函数是解决异步编程问题产生,所谓promise,简单说就是一个容器,里面保存着某个未来才会结束的事件从语法上说,promise是一个对象,从它可以获取异步操作的消息，prominse提供统一的API,各种异步操作都可以用同样的方法通过进行处理

**特点：**

1.对象的状态不受外界影响 有三种状态：pedding(等待中) fulfilled(已成功) rejected(已失败)

一旦状态改变,就不会再变,任何时间都可以得到这个结果 如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果,这与事件(event loop)完全不同,事件的特点是，如果你错过了它，再去监听,是得不到结果的

**概念:promise是一个容器,里面存放着异步事件**

**语法：promise是一个对象,可以获取异步操作的消息**

**promise的返回值无论是不是promise函数,最终都会被封装promise函数进行返回,需要我们用then方法**

2.状态的变化：

​      2.1 从等待中到已成功(pedding -> fulfilled)

​      2.2 从等待中到已失败(pedding -> rejected)

3.一旦状态确定,便不在更改,状态凝固--->resolved   (无论什么时候都监听我 我就是这个样子)

4.和事件循环的区别

事件循环一旦错过,不会再被监听到

promise状态凝固,永远都可以被监听到

.promise的回调参数

.resolve->成功的回调

.reject-> 失败的回调

5.promise的方法

​       **1.then**

​       **2.catch**

​                 2.1 在链式调用中,catch只能捕捉第一个then返回的错误信息

​                 2.2 在链式调用中,想要单独的捕捉每个then的错误信息,需要每个then后面去跟随catch来进行捕获

​      **3.all方法**

​                3.1 语法：promise.all([p1,p2,p3]).then(res=>console.log(res))

​                3.2 特点

​                       1.接受的参数为数组[]

​                       2.返回值为一个数组,进行获取最终的结果

​                       3.必须等待全部参数函数返回成功后,才会执行,不能单独获取任何一个函数的值

​                3.3 缺点

​                        1.任何一个函数崩掉(挂掉)都不能执行

​    **4.race方法**

​                 3.1 语法：promise.race([p1,p2,p3]).then(res=>console.log(res))

​                 3.2 特点

​                          1.接受的参数为数组[]

​                          2.返回值为一个数组,进行获取最终的结果

​                          3.谁先执行完,返回谁,状态就是谁

​      **5.finally**

​                          无论成功或者失败总会执行

​      

```js
 // 实例化promise对象
    let a = new Promise((resolve, reject) => {
        setTimeout(() => {
            // let data='我要休息了'
            // resolve(data)
                //resolve打印成功的消息
            let data1 = '错误信息'
            reject(data1)
            //reject打印失败的消息
        })
    })
    a.then(res => {
        console.log(res);
    }).catch(err => {
        console.log(err);
    })
   //实例化的a就可以使用.then.catch
```

```js
  // 1.实例化promise函数
    // 通过 new xmlhttoprequest 实例化连接对象
    // 3.确定请求方式,以及请求的接口路径
    // 4.发送请求
    // 5.绑定事件,处理响应结果
    // 6.prominse函数的调用

 
        // 用Promise封装原生ajax请求
        const p = new Promise((resolve, reject) => {
            // 实例化Promise构造函数
            var xhr = new XMLHttpRequest()
            console.dir(xhr);
            // 创建原生ajax对象
            xhr.open("GET", "https://elm.cangdu.org/v1/users/count");
            // 确定请求方式和路径open("请求方式","请求资源的地址");
            xhr.send()
            // 发送请求
            xhr.onreadystatechange = function () {
                // onreadystatechange 事件 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 
                // 每当 readyState 改变时，就会触发 onreadystatechange 事件。
                // AJAX请求发送后，readyState状态就会改变，readyState状态一改变就执行onreadystatechange函数。其中readyState状态为4的话，就是请求发送完成
                if (xhr.readyState == 4) {//readyState是请求状态
                    if(xhr.status==200||xhr.status==304){//status可以查看到请求资源的状态，200与304就代表成功获取资源，例如404这些就是请求失败
                        resolve(xhr.response)//请求消息(request)和响应消息(response) 
                    }
                    else{
                        reject(xhr.response)
                    }
                }
            }
        })

        p.then(res=>{
            console.log(res);
        },err=>{
            console.log(err);
        })
        //readyState的请求状态
        // 0	AJAX开始初始化
        // 1	开始发送AJAX请求
        // 2	AJAX请求发送完成
        // 3	开始解析响应的资源
        // 4	AJAX请求的步骤全部完成
```

```js
const fs=require('fs')
const p=new Promise((resolve, reject) => {
    fs.readFile('./为学.md',(err,data)=>{
        if(err) reject(err)
       resolve(data)
    })
})
p.then(function(value){
    console.log(value.toString());
}),function(reason){
    console.log('读取失败');
}
```

```js
//链式调用代码抽离
const fs = require('fs')
// 引入fs
function fn(url) {
    return new Promise((resolve, reject) => {
        fs.readFile(url, (err, data) => {
            if (err) reject(err)
            resolve(data)
        })
    })
}
// 封装一个函数,吧地址作为参数传进入

fn('./poetry/黄鹤楼.md').then(res => {
    return res.toString()
}).then(data => {
    console.log(data);
    fn('./poetry/望庐山瀑布.md').then(res => {
        // return res.toString()
        console.log(res.toString());
    })
}).then(() => {
    fn('./poetry/咏柳.md').then(res => {
        console.log(res.toString());
    })
})
```

```js
//all方法
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    const getlist = `
    故人西辞黄鹤楼，烟花三月下扬州。
孤帆远影碧空尽，唯见长江天际流。
                 `;
    const getlist1 = `
    故人西辞黄鹤楼，烟花三月下扬州。
孤帆远影碧空尽，唯见长江天际流。
                 `;
    const getlist2 = `
    故人西辞黄鹤楼，烟花三月下扬州。
孤帆远影碧空尽，唯见长江天际流。
                 `;

    let setlist = new Promise((resolve, reject) => {
        // resolve(getlist)
        setTimeout(() => {
            reject('我是错误')
        }, 1000)
    })
    let setlist1 = new Promise((resolve, reject) => {
        // resolve(getlist1)
        setTimeout(() => {
            reject('我是错误123')
        }, 500)

    })
    let setlist2 = new Promise((resolve, reject) => {
        // resolve(getlist2)
        // reject('我是错误444')

    })
    Promise.all([setlist, setlist1, setlist2]).then(res => {
        console.log(res);
    }).catch(err => {
        console.log(err);
    })
</script>
```

```js
//race方法
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    const p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(11111)
        }, 300)
    })


    const p2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(22222)
        }, 500)
    })


    const p3 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(33333)
        }, 2000)
    })

    // race：竞技/竞赛
    // 只要有一个promise变成fulfilled状态,那么就结束
    Promise.race([p1, p2, p3]).then(res => {
        console.log('res', res);
    }).catch(err => {
        console.log('err', err);
    })
</script>
```



#### 1. Promise出现的原因

- 为了解决异步回调地狱问题

- 为了解决信任问题(第三方回调函数是不是只执行一次,性能,和执行多次)
- 为了解决回调执行顺序问题
- 为了解决捕捉错误能力(400 500)

# day-06

## 1. async和await

**1.概念**

​    async：快速创建一个异步函数,且是基于promise函数封装

​    在一个函数的开头添加async,就可以使其成为一个异步函数,在异步函数中,你可以在调用一个返回Promise的函数之前使用await关键字

​    在js中,可以通过async关键字来快速创建异步函数,异步函数也就意味着该函数的执行不会阻塞后面代码的执行,async函数也是函数,平时  

​    怎么使用函数就怎么使用它,async函数返回的是一个promise对象,如果要获取到promise返回值,我们应该用then方法

**2.特点**

 优点

它是把异步请求变成同步执行的,async放在最近函数外调用,返回的是promise对象

 1.方便级联调用：即调用依次发生的场景;

 2.同步代码编写方式：promise使用then函数进行链式调用,一直点点点,是一种从左往右的横向写法:async/await从上到下,顺序执行,就像写同步代码一样,更符合代码编写习惯

缺点

没有catch错误处理，需要用js原生的try catch进行错误处理

**3.调用**

调用异步函数的时候,可以直接在函数前使用await关键字来对其进行调用

   调用await的时候，他会等待promise执行出结果后将结果返回,可以通过变量进行接收结果

  注意：await并不是将异步函数变成同步函数,只是改变了异步函数的调用方法

```js
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
           // function times(){
    //     return 'hello world'
    // }
    // async function aaa(){
    //     let res=await times()
    //     console.log(res);
    // }
    // aaa()




    function fn1() {
        return 10
    }
    function fn2(num) {
        return 10 + num
    }
    function fn3(num) {
        return 10 + num
    }
    function fn4(num) {
        return 10 + num
    }
    function fn5(num) {
        return 10 + num
    }
    async function fn6() {
        let res = await fn1()
        res = await fn2(res)
        res = await fn3(res)
        res = await fn4(res)
        res = await fn5(res)
        console.log(res);
    }
    fn6()
        
        
        
    const getlist = `故人西辞黄鹤楼，烟花三月下扬州。
孤帆远影碧空尽，唯见长江天际流。`;
    const getlist1 = `日照香炉生紫烟，遥看瀑布挂前川。
飞流直下三千尺，疑是银河落九天。`;
    const getlist2 = `碧玉妆成一树高，万条垂下绿丝绦。
不知细叶谁裁出，二月春风似剪刀。`;

    function getlists() {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                // resolve(getlist)   //成功的信息
                reject('我是错误的参数')   //错误的信息
            })
        })
    }

    async function getlists1() {
        try{
        let res = await getlists()
        console.log(res);
        }catch(err){          //获取失败的回调
            console.log(err);
        }
     
    }
    getlists1()
</script>
```



## 2. Map对象

**1.概念**

Map是ES6提供的数据结构,它类似于对象,也是键值对的集合,但是键的范围不限于字符串,各种类型的值(包括对象)都可以当作键，



**2.map的方法使用**

- 使用：new Map()
- 判断长度：map.size
- 添加元素：map.set()
- 获取键值：map,get()
- 判断当前对象存不存在该属性：map.has
- 删除当前对象中的属性：map.delete
- 清空该方法的所有成员：map.clear

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    // 概念：为了提供过更多数值类型的键,

    // 声明一个map函数
    const map=new Map()

    // 1.set一个属性
    map.set('name','小兰')
    // 2.如何set一个方法
    map.set('change',function(){
        console.log('我想去日本');
    })
      let key={
          school:'SCHOOL'
      }
      map.set(key,['清华','北大','日本大学','东京大学'])
      console.log(map);

    //   3.删除其中一个key
    map.delete('name')
    console.log(map);
    // 判断当前的键是否存在map中
    console.log(map.has('change'));
    console.log(map.has('keys'));
    // 获取一个map
    console.log(map.get('change'));
    console.log(map.get(key));
    // 判断长度
    console.log(map.size);
    // 遍历
    for(let key of map){
        console.log(key);
    }
    // 清空clear
   console.log(map.clear);
</script>
```

## 3. Set数组

**1.概念**

ES6提供了新的数据结构Set,他类似于数组,但是成员的值都是唯一的,没有重复的值

**2.本质是一个构造函数**

**3.set方法使用**

- 获取元素的个数：array.size()
- 添加元素：array.add()
- 删除元素：array.delete()
- 检测是否存在这个值：array.has()
- 清空：array.clear()

**4.set的实例遍历操作**

- set.prototype.keys() 返回键名的遍历器
- set.prototype.values() 返回键值的遍历器
- set.prototype.entries() 返回键值对的遍历器
- set.prototype.foreach() 使用回调函数遍历每个成员

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    // 1.新建一个set数组
    let set=new Set()
    console.log(set);

    // 2.添加元素 只能单独进行添加
    set.add('梅西')
    set.add('万岁')
    console.log(set);
    // 3.删除元素 根据内容来进行删除元素
    set.delete('万岁')
    console.log(set);
    // 4.检测是否存在这个值
    console.log(set.has('梅西'));
    // 5.遍历循环
    for(let key of set){
        console.log(key);
    }
    // 6.获取长度
    console.log(set.size);

    // 去重方法
    let array=[1,1,1,1,2,2,2,3,3,3,5,6,7]
//    1.set方法
    let res=new Set(array)
    console.log(res);
//    2.扩展运算符转换为一个数组
    let res1=[...res]
    console.log(res1);
    // 3.Array.from()转换为一个数组
   let res2=Array.from(res)
   console.log(res2);
  
</script>
```



# day-07

## 1. ES6class类

**概念:**

ES6 提供了更接近传统语言（java）的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。

ES6的class可以看作只是一个语法糖,

es6提供了更接近传统语言的写法,引入了class这个概念,作为对象的模板

**作用：**

class关键字,可以定义类

**优点：**

新的class写法只是让对象原型的写法更加清晰,更像面向对象编程的语法而已,

```js
// 传统es5的写法
    // function Point(x, y) {
    //     this.x = x;
    //     this.y = y;
    // }
    // Point.prototype.toString = function () {
    //     return '(' + this.x + ',' + this.y + ')';
    // }
    // var p = new Point(1, 2);
    // let result = p.toString()
    // console.log(result);


    // es6class的写法
    class Point {
        constructor(x, y) {
            this.x = x
            this.y = y
        }
        String() {
            return '(' + this.x + ',' + this.y + ')'
        }
    }
    let p = new Point(1, 2)
    let rul = p.String()
    console.log(rul);
```

```js
   // es5写法 构造函数
    function Phone(brand,price){
        this.brand=brand
        this.price=price
    }
    Phone.prototype.call=function(){
        console.log('我手机可以敲核桃');
    }
    Phone.prototype.info=function(){
        return '(我手机的型号是:'+this.brand+',我手机的价格是:'+this.price+',我手机铃声是好运来)'
    }
    let p1=new Phone('诺基亚','129')
    let ruls=p1.info()
    console.log(ruls);
   
   

    // es6写法 class定义
    class Phins {
        constructor(brand, price) {
            this.brand = brand,
            this.price = price
        }
        call(){
            console.log('我是可以打电话的');
        }
        info(){
            return '(我手机的型号是:'+this.brand+',我手机的价格是:'+this.price+',我手机铃声是好运来)'
        }
    }
    let p=new Phins('诺基亚','129')
    let rul=p.info()
    console.log(rul);
```



**class get set**

- get可以修改对象的属性

- set不要修改自身，这样会导致递归爆栈

- 因为set a无法直接修改get a返回的值,所以需要先通过一个第三方对象属性来缓存set a的结果来供get a调用,这类似于交换两个变量的做法

- class里不要有与get,set同名的属性,有的话会导致get,set不被触发

```js
// class get set    
class phone{
        get price(){
            console.log('价格属性被读取了');
            return 'iloveyou';
        }
        set price(newVal){
            console.log("价格属性被修改了");
        }
    }

    // 实例化对象

    let s=new phone()
    console.log(s.price);
    s.price='free'
```



**class static(死带来可)定义方法**

​     概念：类(class) 通过 static 关键字定义静态方法

​     特点：不能在类的实例上调用静态方法,而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能

类的继承

```js
//static定义方法
   class Tripple {
        static tripple(n = 1) {
            return n * 3
        }
    }

    class BiggerTripple extends Tripple {
        static tripple(n) {
            return super.tripple(n) * super.tripple(n)
        }
    }

    // 这是类调用自身的方法
    console.log(Tripple.tripple());

    console.log(Tripple.tripple(6));

    // 实例化对象
    let tp = new Tripple()

    console.log(BiggerTripple.tripple(3));

    // console.log(tp.tripple());    //不是一个函数
```



关键字：extends 

关键字：super()       父类 .call(this)

```js
//原生的继承方法    
function Phone(brand,price){
        this.brand=brand;
        this.price=price
    }
    Phone.prototype.call=function(){
        console.log('我可以打电话');
    }

    function Smpphone(brand,price,color,size){
        Phone.call(this,brand,price)
         this.color=color
         this.size=size
}

   Smpphone.prototype=new Phone
   Smpphone.prototype.constructor=Smpphone
   Smpphone.prototype.photo=function(){
       console.log('我可以拍照');
   }
   Smpphone.prototype.play=function(){
       console.log('我可以玩游戏');
   }
   let arr=new Smpphone('诺基亚',199,'粉色','5.5inch')
   console.log(arr);




//es6继承
  class phone {
        //   构造函数
        constructor(brand, price) {
            this.brand = brand
            this.price = price
        }
        //   父类的成员属性
        call() {
            console.log('我可以打电话!');
        }
    }

    class SmartPhone extends phone {
        //   构造方法
        constructor(brand, price, color, size) {
            super(brand, price)
            this.color = color;
            this.size = size;
        }
        photo() {
            console.log('拍照');
        }

        playganme() {
            console.log('玩游戏');
        }
        call() {
            console.log('我可以进行视频通话');
        }
    }
    const huawei = new SmartPhone('小米', 799, '黑色', '4.7inch')

    huawei.call()
    huawei.photo()
    huawei.playganme()
```

## 2.ES6数值的扩展

### 1.Number.EPSILON

表示最小精度

数组的方法 Math.abs: 取绝对值 |1-2|=1

```js
   function equal(a, b) {
        if (Math.abs(a - b) < Number.EPSILON) {
            return true
        } else {
            return false
        }
    }

    // console.log(0.1 + 0.2 === 0.3);
    // console.log(equal(0.1 + 0.2, 0.3));
```

### 2. 二进制和八进制

```js
    let b=0b1010;
    let o=0o777;
    //  二进制和八进制
   
    let d=100
    let x=0xff;
     // 十进制
```

### 3. Number.isFinite

检测一个数值是否为有限数 小数和长度是有限的 , 无线数表示是位数是无止尽的

```js
    // 2.检测一个数值是否为有限数
    console.log(Number.isFinite(100));
    console.log(Number.isFinite(100/0));
    console.log(Number.isFinite(Infinity));
     Infinity 无穷大
```

### 4.Number.isNaN

判断一个数值是不是NaN

```JS
 // 3.检测一个数值是否为NaN
   console.log(Number.isNaN(123));
```

### 5. Number.parsetInt 

```js
 console.log(Number.parseInt('123123love'));
```



### 6. Number.parseFloat

```js
 console.log(Number.parseFloat('3.1415926神奇'));
```

### 7. Number.isInteger

判断一个数是不是整数

```js
//    判断一个数是否为整数
console.log( Number.isInteger(5));    //true
console.log( Number.isInteger(2.5));    //false
```

### 8. Math.trunc

将数字的小数部分抹掉

```js
//    将数字的小数部分抹掉
console.log(Math.trunc(3.5));    //3
```

### 9. Math.sign

判断一个数到底为正数 负数 还是零

```js
// 判断一个数到底为正数 负数 还是零
console.log(Math.sign(100));    //1
console.log(Math.sign(0));     //0
console.log(Math.sign(-20000));   //-1
```

## 3. Proxy

### 1.概念

Proxy对象用于创建一个对象的代理,从而实现基本操作的拦截和自定义(如属性查找,赋值,枚举,函数调用等)

```js
 let obj = new Proxy({}, {
        get: function (target, key, receiver) {
            console.log(`获取当前${key}`);
            return Reflect.get(target, key, receiver)
        },
        set: function (target, key, value, receiver) {
         //console.log(target);    //需要代理的对象
         //console.log(key);    //设置的一个属性名
         //console.log(value);   //设置的属性值
       //console.log(receiver);   //代理后的目标对象
         console.log(`设置当前${key}`);
    return Reflect.set(target, key, value, receiver)
        },
    })
    obj.count = 1
    ++obj.count
    console.log(obj);
```



应用场景

- v3的reactive的双向绑定原理

##  4. import和export使用

node编程中最重要的思想就是模块化,import和require都是被模块化所使用,在ES6当中,用export导出接口,用import引入模块,但是在node模块中,使用module.exports导出接口,使用require引入模块.



### 遵循规范：

- require是AMD规范引入方式
- import是ES6的一个语法标准,如果要兼容浏览器的话必须转化成ES5的语法

### 调用时间：

- require是运行时调用，所以require理论上可以运用在代码的任何地方
- import是编译时调用,所以必须放在文件开头

## 本质：

- require是赋值过程.module.exports后面的内容是什么,require的结果就是什么,比如对象,数字,字符串,函数等,然后再把require的结果赋值给某个变量,它相当于module.exports的传送门
- import是解构过程,但是目前所有的引擎都还没有实现inport,我们在node中使用babel支持ES6,也仅仅是将ES6转码为ES5再执行,import语法会被转码为require
- import虽然是es6中的语法,但就目前来说,所有的引擎都还没有实现import

# day-08

## 1.vue介绍

- Vue是一套用于构建用户界面的**渐进式框架**。

- 构建用户界面：把数据通过某种办法变成用户界面

- 渐进式：Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，简单应用只需要一个轻量小巧的核心库,复杂应用可以引入各式各样的Vue插件

### 1.1 Vue的特点

1. 遵循MVVM模式
2. 编码简洁,体积小,运行效率高,适合移动/PC端开发
3. 它本身只关注UI,也可以引入其它第三方库开发项目
4. 采用组件化模式,提高代码复用率,且代码更好的维护
5. 声明式编码,让编码人员无需直接操作DOM,提高效率

### 1.2 Vue 周边库

vue-cli:vue 脚手架

vue-resource

axios

vue-router:路由

vuex:状态管理

element-ui：基本vue的UI组件库(PC端)

## 2. 其他语言介绍

市场上和vue并行的三大语言框架为



- React:它也有一定程度的主张,它的主张主要是函数式编程的理念,比如说,你需要知道什么是副作用,什么是纯函数,如何隔离副作用,它的侵入性看似没有Anguiar那么强,主要因为它是软性侵入.

- Angular:它两个版本都是强主张的,如果你用它,必须接受以下东西,

​       -必须使用它的模块机制

​       -必须使用它的依赖注入

​       -必须使用它的特殊形式定义组件(这一点每个视图框架都有,难以避免)

​       所以Angular是带有比较强的排它性的,如果你的应用不是从头开始,而是要不断考虑是否跟其他东西集成,这些主张会带来一些困扰

Vue:渐进式框架,主张就是只负责自己的事情,Vue被设计为可以自底向上逐层应用,Vue的核心库只关注视图层,不仅易于上手,还便于与第三方库或既有项目整合,再不同层次可以使用不同的概念

## 3.对于pwa的解释

```js
一是给项日添加一些webapp支持，比如在手机端支持发送到桌面图标，根据不同平台和浏览器尝试去掉河览器自带的地址栏、底栏实现全屏体验，这个主要是视觉上和体验上的，没有什么实际功能。
实现方式就是勾选pwa支持后项目会生成manifest.json，在里面配置即可
二是增加可高线支持。其实可离线也不一定非要用pwa，有不少其他手段。可离线就是比如你的项目不是一定要全程联网才能实现功能，只要用户访
问过一次你的网站，下一次进入时哪怕没有网络，你的项目也不会白屏，而是照常运行或者开放部分功能，或者给个断网提示等等。对于那些功能性
网站挺有用的，
通过配置项目生成的registerServiceworker . js来注册serviceworker实现，具体探作还是很复杂的，详情百度，


Progressive web App，简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。PWA 能做到原生应用的休验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 web App 和 Native App 的优点。PWA 的主要特点包括下面三点：可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现体验 一 快速响应，并且有平滑的动画响应用户的操作粘性 一 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到
桌面PVA 本身强调渐进式。井不要求一次性达到安全、任能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。
```



## 4.Vue目录简介

```js

```

- vue.config.js   ----   配置webpack文件(包括配置跨域,请求接口,第三插件配置,rule配置)

- Package.json  --- 
  -   scripts:配置启动命令,打包命令,eslint校验代码命令
  - browserslist:浏览器适配配置
  -  devDependencies,dependencies:项目node-modules大版本限制
    
  - ^:最大兼容版本
  - ~:大约在这个版本上下就行

- package-lock.json
  -  约束每个node-modules版本下的其他依赖的固定版本

- babel.config.js:babel插件设置

- .gitgnore:忽略文件
- Public:公共入口文件和公共配置
- src:放置组件和axios配置
  	
  - Assets  --- 放置图片.img .css.js
  - components --- 放置其他组件所需要的公共组件
    
  - router --- 配置路由表(动态路由,静态路由,权限路由)
    
  - store  --- 存放vuex的仓库
  - Views --- 放置页面的地方

- App.vue 入口的总文件
  
- main.js 实例化vue挂载
  
- Utils--- 所有封装axios,封装token,封装公共方法-工具类文件

## 5. Vue的语法

1.插值语法 {{}}

2.动态绑定 v-bind(:)

3.条件渲染：v-if v-else

​       概念：控制dom元素的创建和销毁,实现渲染和更新页面

​      特点：如果没有v-else的存在,会在dom元素被删除的地方,添加一个标识,在下次进行重新渲染的时候,优先寻找有标识的地方,尽量减少dom的循环和查找

4.v-show

​    通过添加或者移除display:none样式进行控制dom元素的显示与隐藏

5.v-for

​    1.key:作用为了防止Dom元素的重复渲染,如果以index为key的话,会造成页面的多次渲染和渲染不同

​      2.diff算法对比节点:同级节点对比,确认和获取每个节点,通过key标识来进行对比





